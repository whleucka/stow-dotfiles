#!/usr/bin/env python3
import json
import subprocess
import sys
import os
from pathlib import Path
from datetime import datetime

SESSION_DIR = Path.home() / ".local/share/kitty-sessions"
SESSION_DIR.mkdir(parents=True, exist_ok=True)

def run_kitty_cmd(*args):
    """Run a kitty remote-control command and return parsed JSON if possible."""
    result = subprocess.run(["kitty", "@"] + list(args), capture_output=True, text=True)
    if result.returncode != 0:
        print(f"Error: {result.stderr.strip()}")
        sys.exit(1)
    try:
        return json.loads(result.stdout)
    except json.JSONDecodeError:
        return result.stdout.strip()

# ----------------------------------------------------------
# SAVE SESSION
# ----------------------------------------------------------
def save_session(name):
    data = run_kitty_cmd("ls")
    session_data = {
        "created": datetime.now().isoformat(),
        "windows": []
    }

    for win in data:
        win_info = {"tabs": []}
        for tab in win["tabs"]:
            # Handle layout + options
            layout_name = tab.get("layout", "splits")
            if isinstance(layout_name, dict):
                name_str = layout_name.get("name", "splits")
                opts = layout_name.get("options", {})
                if opts:
                    opt_str = ";".join(f"{k}={v}" for k, v in opts.items())
                    layout_name = f"{name_str}:{opt_str}"
                else:
                    layout_name = name_str

            tab_info = {
                "title": tab.get("title", ""),
                "layout": layout_name,
                "layout_opts": tab.get("layout_opts", {}),
                "windows": []
            }
            for w in tab["windows"]:
                tab_info["windows"].append({
                    "title": w.get("title", ""),
                    "cwd": w.get("cwd", ""),
                    "cmdline": w.get("cmdline", []),
                    "location": w.get("layout", "stack")
                })
            win_info["tabs"].append(tab_info)
        session_data["windows"].append(win_info)

    with open(SESSION_DIR / f"{name}.json", "w") as f:
        json.dump(session_data, f, indent=2)
    print(f"Session '{name}' saved.")

# ----------------------------------------------------------
# LOAD SESSION - ALTERNATIVE APPROACH
# ----------------------------------------------------------
def load_session(name):
    session_file = SESSION_DIR / f"{name}.json"
    if not session_file.exists():
        print(f"Error: No session named '{name}'")
        sys.exit(1)

    with open(session_file) as f:
        session_data = json.load(f)

    for win in session_data["windows"]:
        for tab in win["tabs"]:
            layout_str = tab.get("layout", "splits")
            windows = tab["windows"]

            if not windows:
                continue

            # Check if we have bias in the layout
            bias_value = None
            if "bias=" in layout_str:
                # Extract bias value
                for part in layout_str.split(";"):
                    if "bias=" in part:
                        bias_value = int(part.split("=")[1])
                        break

            # Start with basic layout
            base_layout = layout_str.split(":")[0] if ":" in layout_str else layout_str
            
            # First window
            first_win = windows[0]
            cwd = first_win.get("cwd", str(Path.home()))
            cmd = first_win.get("cmdline", [])
            title = first_win.get("title", "")

            subprocess.run(["kitty", "@", "new-window", "--title", title, "--cwd", cwd] + cmd)

            # Create remaining windows with specific bias if available
            for i, w in enumerate(windows[1:], 1):
                cwd = w.get("cwd", str(Path.home()))
                cmd = w.get("cmdline", [])
                title = w.get("title", "")
                location = w.get("location", "after")
                
                launch_cmd = ["kitty", "@", "launch", "--location", location, "--title", title, "--cwd", cwd]
                
                # Try adding bias to the launch command
                if bias_value and i == 1:  # Only for the second window
                    # Calculate inverse bias for second window
                    second_bias = 100 - bias_value
                    launch_cmd.extend(["--bias", str(second_bias)])
                
                launch_cmd.extend(cmd)
                subprocess.run(launch_cmd)

            # Apply the base layout
            subprocess.run(["kitty", "@", "goto-layout", base_layout])

    print(f"Session '{name}' loaded.")

# ----------------------------------------------------------
# OTHER FUNCTIONS (unchanged)
# ----------------------------------------------------------
def edit_session(name):
    session_file = SESSION_DIR / f"{name}.json"
    if not session_file.exists():
        print(f"Error: No session named '{name}'")
        sys.exit(1)
    editor = os.environ.get('EDITOR') or os.environ.get('VISUAL')
    if not editor:
        for candidate in ['nvim', 'vim', 'nano', 'code', 'gedit']:
            if subprocess.run(['which', candidate], capture_output=True).returncode == 0:
                editor = candidate
                break
        else:
            print("Error: No editor found.")
            sys.exit(1)
    subprocess.run([editor, str(session_file)])
    print(f"Finished editing session '{name}'")

def list_sessions():
    sessions = sorted(f.stem for f in SESSION_DIR.glob("*.json"))
    if not sessions:
        print("No saved sessions.")
        return []
    for s in sessions:
        print(s)
    return sessions

def delete_session(name):
    session_file = SESSION_DIR / f"{name}.json"
    if session_file.exists():
        session_file.unlink()
        print(f"Deleted session '{name}'")
    else:
        print(f"No session named '{name}'")

def pick_session():
    sessions = list_sessions()
    if not sessions:
        return
    preview_cmd = "python3 ~/.local/bin/kitty_preview {}"
    try:
        result = subprocess.run(
            ["fzf", "--preview", preview_cmd],
            input="\n".join(sessions),
            text=True,
            capture_output=True,
            shell=True
        )
        chosen = result.stdout.strip()
        if chosen:
            load_session(chosen)
    except FileNotFoundError:
        print("Error: fzf not installed.")
        sys.exit(1)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: kitty-session [save|load|list|delete|pick|edit] <name>")
        sys.exit(1)

    cmd = sys.argv[1]
    if cmd == "save" and len(sys.argv) == 3:
        save_session(sys.argv[2])
    elif cmd == "load" and len(sys.argv) == 3:
        load_session(sys.argv[2])
    elif cmd == "list":
        list_sessions()
    elif cmd == "delete" and len(sys.argv) == 3:
        delete_session(sys.argv[2])
    elif cmd == "pick":
        pick_session()
    elif cmd == "edit" and len(sys.argv) == 3:
        edit_session(sys.argv[2])
    else:
        print("Usage: kitty-session [save|load|list|delete|pick|edit] <name>")
        sys.exit(1)
