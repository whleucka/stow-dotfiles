#!/usr/bin/env zsh
fg() {
    if [[ $# -eq 1 && $1 = - ]]; then
        builtin fg %-;
    elif [[ "$*" =~ ^[0-9]+$ ]]; then
        builtin fg %"$*";
    else
        builtin fg "$@";
    fi
}

tsm() { transmission-remote -l; }
tsm-f() { watch 'transmission-remote -l'; }
tsm-init() { transmission-daemon --no-auth; }
tsm-pause() { transmission-remote -t "$1" --stop; }
tsm-start() { transmission-remote -t "$1" -s; }
tsm-enablealtspeed() { transmission-remote --alt-speed; }
tsm-disablealtspeed() { transmission-remote --no-alt-speed; }
tsm-purge () { transmission-remote -t "$1" --remove-and-delete; }
tsm-remove () { transmission-remote -t "$1" -r; }
tsm-info () { transmission-remote -t "$1" -i; }
tsm-speed () { transmission -t"$1" -i | grep speed; }
tsm-add () { transmission-remote -a "$1"; }
tsm-pauseall () { transmission-remote -tall -S; }
tsm-startall () { transmission-remote -tall -s; }
tsm-search () { echo "================================="; transmission-remote -l | grep -i $1; }

portal-up() {
    wg-quick up will_laptop
}

portal-down() {
    wg-quick down will_laptop
}

what() {
    curl cheat.sh/$1;
}

killer() {
  local selection
  
  # List processes with PID and command, then pass to fzf
  selection=$(ps -eo pid,user,command --no-headers | fzf --height=40% --reverse --prompt="Select process to kill: ")
  
  if [[ -n "$selection" ]]; then
    local pid=$(awk '{print $1}' <<< "$selection")
    echo "Killing process: $selection"
    kill -9 "$pid"
  else
    echo "No process selected."
  fi
}

check-url() {
    curl -Ifs "$1" > /dev/null
}

nvim-update() {
    local build="${1:-nightly}"
    local nvim_dir="$HOME/.neovim"
    local cwd=$(pwd)
    local directory=""
    local filename=""
    local target=""

    echo "One moment..."

    # Detect installed version
    if command -v nvim >/dev/null; then
        local current_version
        current_version=$(nvim -v | awk 'NR==1{print $2}')
        if [[ "$current_version" == "$build" ]]; then
            echo "You already have Neovim $current_version"
            return 0
        fi
        echo "Updating Neovim: $current_version → $build"
        rm -rf "$nvim_dir"
    else
        echo "Installing Neovim $build"
    fi

    mkdir -p "$nvim_dir"
    cd "$nvim_dir" || { echo "Failed to enter $nvim_dir"; return 1; }

    # Try URLs in order
    local URLs=(
        "https://github.com/neovim/neovim/releases/download/$build/nvim-linux-x86_64.tar.gz"
        "https://github.com/neovim/neovim/releases/download/$build/nvim-linux64.tar.gz"
    )

    for url in "${URLs[@]}"; do
        if curl -Ifs "$url" >/dev/null; then
            target="$url"
            filename="${url##*/}"
            directory="${filename%.tar.gz}"
            echo "Download target: $filename"
            break
        fi
    done

    if [[ -z "$target" ]]; then
        echo "Failed to find a working Neovim download URL."
        return 1
    fi

    # Download if missing or older than 1 day
    if [[ ! -f "$filename" || "$(find "$filename" -mtime +1 2>/dev/null)" ]]; then
        echo "Fetching latest Neovim build..."
        rm -rf "$directory" "$filename"
        curl -LO "$target" || { echo "Download failed"; return 1; }
        tar -xzf "$filename" || { echo "Extraction failed"; return 1; }
    else
        echo "Neovim tarball is less than 1 day old; skipping download."
    fi

    cd "$cwd" || return 1
    echo "Done!"
}

extract() {
    local file="$1"

    [[ -z "$file" ]]     && { echo "Usage: extract <file>"; return 1; }
    [[ ! -f "$file" ]]   && { echo "Error: '$file' not found"; return 1; }

    # Strip known extensions to derive folder name
    local dir="$file"
    dir="${dir%.tar.bz2}"
    dir="${dir%.tar.gz}"
    dir="${dir%.tar.xz}"
    dir="${dir%.tar.zst}"
    dir="${dir%.tar}"
    dir="${dir%.bz2}"
    dir="${dir%.gz}"
    dir="${dir%.xz}"
    dir="${dir%.zst}"

    # Clean up directory name if needed
    dir="${dir##*/}" # strip path

    # Avoid overwrite
    if [[ -d "$dir" ]]; then
        dir="${dir}_extracted_$(date +%s)"
    fi

    mkdir -p "$dir"

    echo "→ Extracting '$file' → '$dir/'"

    case "$file" in
        *.tar.bz2)  tar -xjf "$file" -C "$dir" ;;
        *.tar.gz)   tar -xzf "$file" -C "$dir" ;;
        *.tar.xz)   tar -xJf "$file" -C "$dir" ;;
        *.tar.zst)  tar --use-compress-program=unzstd -xf "$file" -C "$dir" ;;
        *.tar)      tar -xf "$file" -C "$dir" ;;
        *.bz2)      bunzip2 -k "$file"; mv "${file%.bz2}" "$dir/" ;;
        *.gz)       gunzip -k "$file";  mv "${file%.gz}" "$dir/" ;;
        *.xz)       unxz -k "$file";    mv "${file%.xz}" "$dir/" ;;
        *.zst)      unzstd -k "$file";  mv "${file%.zst}" "$dir/" ;;
        *)          echo "Unsupported file type: $file"; return 1 ;;
    esac

    echo "✔ Done."
}

archive() {
    if [[ $# -lt 2 ]]; then
        echo "Usage: archive <output_name> <file_or_dir> [more_files...]"
        return 1
    fi

    local output="$1"; shift
    local compressor=""
    local tar_ext=""

    # Mapping of extensions → best compressor
    declare -A COMPRESSORS=(
        [gz]="$(command -v pigz >/dev/null && echo pigz || echo gzip)"
        [bz2]="$(command -v pbzip2 >/dev/null && echo pbzip2 || echo bzip2)"
        [xz]="$(command -v pxz >/dev/null && echo pxz || echo xz)"
        [zst]="$(command -v zstd >/dev/null && echo zstd || echo gzip)"
        [tar]=""
    )

    case "$output" in
        *.tar.gz)   tar_ext="gz" ;;
        *.tar.bz2)  tar_ext="bz2" ;;
        *.tar.xz)   tar_ext="xz" ;;
        *.tar.zst)  tar_ext="zst" ;;
        *.tar)      tar_ext="tar" ;;
        *)
            echo "Error: output must end in .tar, .tar.gz, .tar.bz2, .tar.xz, or .tar.zst"
            return 1
            ;;
    esac

    compressor="${COMPRESSORS[$tar_ext]}"

    echo "→ Creating archive '$output'..."

    if [[ "$tar_ext" == "tar" ]]; then
        tar -cf "$output" "$@" || { echo "Archive failed"; return 1; }
    else
        tar --use-compress-program="$compressor" -cf "$output" "$@" \
            || { echo "Archive failed"; return 1; }
    fi

    echo "✔ Archive created: $output"
}

backup_drive() {
  if [[ $# -lt 1 || $# -gt 2 ]]; then
    printf "Usage: backup_drive <source_device> [target.img]\n"
    return 1
  fi

  local source="$1"
  local target="$2"
  local logfile="/var/log/backup_drive.log"

  # Logging helper
  log() {
    printf "%s\n" "$1" | sudo tee -a "$logfile" > /dev/null
  }

  # Check source device
  if [[ ! -e "$source" ]]; then
    log "Error: Source device '$source' does not exist."
    return 1
  fi

  # Auto-generate target if missing
  if [[ -z "$target" ]]; then
    local name="$(basename "$source")"
    local stamp="$(date +%Y%m%d_%H%M%S)"
    target="./${name}_${stamp}.img"
    printf "No target provided — using: %s\n" "$target"
  fi

  log "Starting backup of '$source' to '$target' at $(date)"

  # Perform the dd backup
  if sudo dd if="$source" of="$target" bs=4M status=progress conv=noerror,sync; then
    log "Backup completed successfully at $(date)"
  else
    log "Backup FAILED at $(date)"
    return 1
  fi
}

cc() {
if [[ $# -lt 1 || $# -gt 2 ]]; then
    printf "Usage: compress_copy <source> [target.tar.gz]\n"
    return 1
  fi

  local source="$1"
  local target="$2"

  # Validate source
  if [[ ! -e "$source" ]]; then
    printf "Error: Source '%s' does not exist.\n" "$source"
    return 1
  fi

  # Auto-generate target if missing
  if [[ -z "$target" ]]; then
    local name="$(basename "$source")"
    local stamp="$(date +%Y%m%d_%H%M%S)"
    target="./${name}_${stamp}.tar.gz"
    printf "No target provided — using: %s\n" "$target"
  fi

  # Validate extension
  if [[ "$target" != *.tar.gz ]]; then
    printf "Error: Target must end with .tar.gz\n"
    return 1
  fi

  # Temporary tarball
  local tmp="/tmp/$(basename "$source")_$(date +%Y%m%d_%H%M%S).tar.gz"

  printf "→ Compressing '%s'...\n" "$source"
  if ! tar -czf "$tmp" -C "$(dirname "$source")" "$(basename "$source")"; then
    printf "Compression failed!\n"
    return 1
  fi

  printf "→ Copying to '%s'...\n" "$target"
  if ! rsync -ah "$tmp" "$target"; then
    printf "Copy failed!\n"
    rm -f "$tmp"
    return 1
  fi

  rm -f "$tmp"
  printf "✔ Done! Saved compressed archive to %s\n" "$target"
}
